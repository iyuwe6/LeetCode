### 问题描述
给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。

### 示例
给出 n = 3，生成结果为：
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]

### 解题思路
#### 1.深度优先遍历（回溯）
有效括号需满足的条件是：
1.最终结果左括号数和右括号都是n；
2.有效括号从左往右生成过程中始终要保证左括号数不少于右括号；
所以在满足上述两个条件的情况下，将n个左括号和n个括号，加到最终的结果。n个左括号只要没用完，就可以继续添加，n个右括号需保证剩余的括号数不少于左括号，这里，要么加左括号，要么加右括号，产生分支情况。直到左右括号都用完，将结果加入到结果集中。

#### 2.递归
设所求序列为S[n]，记其序号为n，n为括号的对数。
S[n]可以表示一对左右括号然后加上再括号内和括号外右侧总计n-1对括号。
举例说明，n=3时，求3对括号能组成的有效组合，首先有一对括号“（）”，然后来填充这个括号。可能的填充有：
“（0对括号组合）3-1-0对括号组合”
“（1对括号组合）3-1-1对括号组合”
“（2对括号组合）3-1-2对括号组合”
将S[n]表示为“（左序列）右序列”，并且左右序列的序号之和为n-1，即
S[n] = { 
         '(' + S[n-1] + ')' + S[0], 
         '(' + S[n-2] + ')' + S[1], 
         ...
         '(' + S[1]   + ')' + S[n-2],
         '(' + S[0]   + ')' + S[n-1]
       }
S[3] = {
         ( ()() ), ( (()) ),
         ( () ) (),
         (  ) ()(), (  ) (())
}
