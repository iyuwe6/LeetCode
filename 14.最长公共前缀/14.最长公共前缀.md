### 问题描述
编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 ""。
说明:
所有输入只包含小写字母 a-z 。

### 示例
示例 1:
输入: ["flower","flow","flight"]
输出: "fl"

示例 2:
输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。

### 解题思路
#### 1.水平扫描
水平扫描，依次遍历每一个字符串，每次取一位字符进行比较，若全部字符串都有这一位字符，则加入到最后的前缀中，然后继续判断下一位字符，直到同一为字符不同，或某个字符串位数不够。最后返回得到的前缀。

### 2.水平扫描
首先，我们将描述一种查找一组字符串的最长公共前缀LCP(S1...Sn)的简单方法。
我们将会用到这样的结论：
LCP(S1...Sn) = LCP(LCP(LCP(S1,S2), S3),...Sn)
首先取前两个字符串寻找最长公共前缀，再把结果与下一个字符串求最长公共前缀，继续此过程，直到前缀变为空字符串，表示整个字符串组没有公共前缀，或者遍历完所有字符串，得到整个字符串的最长公共前缀。

### 3.分治
我们可以发现：
LCP(S1...Sn) = LCP(LCP(S1...Sk),LCP(Sk+1...Sn)),其中LCP(S1...Sn)是字符串[S1...Sn]的最长公共前缀，1 < k < n.
根据这一规律，使用分治的思想，将原问题LCP(Si...Sj)分成两个子问题LCP(Si...Smid)与LCP(Smid+1...Sj),其中mid = (i+j)/2。我们用子问题的解lcpLeft与lcpRight构造原问题的解LCP(Si...Sj)LCP(Si...Sj)。从头到尾挨个比较lcpLeft与lcpRight中的字符，直到不能再匹配为止。计算所得的lcpLeft与lcpRight最长公共前缀就是原问题的解LCP(Si...Sj)。

### 4.二分查找
用二分查找法找到所有字符串的公共前缀的最大长度L，算法的查找区间是(0...minLen),其中minLen是输入数据中最短的字符串的长度，同时也是答案的最长可能长度。每一次将查找区间一份为二，然后丢弃一定不包含最终答案的那一个。算法进行的过程中一共会出现两种可能情况：
1.S[1...mid]不是所有串的公共前缀。这表明对于所有的 j > i, S[1...j]也不是公共前缀，于是我们就可以丢弃后半个查找区间；
2.S[1...mid]是所有串的公共前缀。这表示对于所有的 i < j, S[1...i]都是可行的公共前缀，因为我们要找最长的公共前缀，所以我们可以把前半个查找区间丢弃。