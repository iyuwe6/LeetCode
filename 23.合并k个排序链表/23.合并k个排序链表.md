### 问题描述
合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

### 示例
输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6

### 解题思路
#### 1.贪心算法，优先队列
1.这k个排序链表的头节点是每个链表最小的节点，这些头节点中最小的节点则是合并之后的链表中最小的节点，将其取出作为新链表的头节点；
2.上述取出节点的下一个节点成为链表的新头节点（如果有的话），然后再取这k个头节点中最小的节点，将其取出链接到新链表；
3.重复上述过程，直到全部链表的节点取出完毕。
上面就是分析的思路。“局部（头节点）最优，全局（全部节点）就最优”，正是贪心算法的思想。
具体的实现中，用优先队列（或者最小堆，最小索引堆均可）来完成k个头节点中找出最小节点。

#### 2.分治法
这个就用到了21题的解题思路，把这k个链表划分成多个2个链表合并。具体如何将这k个链表两个两个划分呢。有以下几种思路：
1.从前往后，每两个链表合并为一个链表，然后将新合并的链表继续每两个进行合并，直到最后只剩下一个链表，也就是最终合并的结果；
2.将第0个链表与第k-1个链表合并，第1个链表与第k-2个链表合并，依次类推，然后新合并的链表依然按这种方式继续合并，直到得到最终的结果；
3.还有像我代码中的这种方式，将k个链表划分为两个部分，每个部分继续划分，递归下去，得到两个链表予以合并，最终将全部链表合并完毕。