### 问题描述
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

### 示例

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。

输入: "cbbd"
输出: "bb"

### 解题思路
#### 1.中心扩展算法
枚举可能出现回文子串的“中心位置”，然后从“中心位置”尽可能向左右扩散，得到每个位置的最长回文串。思路是：遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，尽可能向左右扩散，直到左右不对称。需要注意的是：
- 奇数回文串的“中心”是一个具体的字符，例如：回文串“aba”的中心是字符"a"；
- 偶数回文串的“中心”是中间两个字符的“间隙”，例如：回文串“abba”的中心是两个"b"中间的那个“间隙”。
所以，根据“中心”的不同，奇数串从“中心”字符向左右扩散，偶数串首先判断相邻字符是否相等，相等的话才向左右扩展。在此过程中，记录最长回文子串的起止位置，并不断更新。最后截取出最长回文子串。
复杂度分析：
- 时间复杂度：O(n^2)
- 空间复杂度：O(1)

#### 2.动态规划算法
动态规划的思想，总是希望把问题划分成相关联的子问题，然后从最基本的子问题出发来推导较大的子问题，直到所有的问题都解决。
思路是：假设字符串s的长度为len，建立一个len*len的矩阵dp。令dp[i] [j]表示s[i]至s[j]的子串是否是回文子串。
1. 当i == j，dp[i] [j]是回文子串，单字符都是回文子串。
2. 当j - i < 3，只要s[i] == s[j]，则dp[i] [j]是回文子串(如"aa"，"aba"),否则不是；
3. 当j - i > 3，只要s[i] == s[j] && dp[i+1] [j-1]，则dp[i] [j]是回文子串，否则不是。
需要注意的是，因为要访问dp[i+1] [j-1]，因此i是从大到小的，j是从小到大的。
复杂度分析：
- 时间复杂度：O(n^2)
- 空间复杂度：O(n^2)

#### 3.Manacher算法
Manacher算法，又称“马拉车”算法，专门用于解决“最长回文子串”问题，时间复杂度为O(N)。
算法简介：
Manacher(1975)发现了一种线性时间算法，可以在列出给定字符串中从字符串头部开始的所有回文。并且，Apostolico, Breslauer & Gaill(1995)发现，同样的算法也可以在任意位置查找全部最大回文子串，并且时间复杂度是线性的。因此，他们提供了一种时间复杂度为线性的最长回文子串解法。替代性的线性时间解决Jeuring(1994), Gusfield(1997)提供的，基于后缀树(suffix trees)。也存在已知的高效并行算法。
Manacher算法本质上还是中心扩散算法，只不过它使用了类似KMP算法的技巧，充分挖掘了已经进行回文判定的子串的特点，在遍历的过程中，记录了已经遍历过的子串的信息，也是典型的以空间换时间思想的提现。
