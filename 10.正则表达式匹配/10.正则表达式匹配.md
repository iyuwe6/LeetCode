### 问题描述
给你一个字符串s和一个字符规律p，请你来实现一个支持'.'和'*'的正则表达式匹配。
'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。

说明:
s 可能为空，且只包含从a-z的小写字母。
p 可能为空，且只包含从a-z的小写字母，以及字符 . 和 *。

### 示例
示例 1:
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。

示例 2:
输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

示例 3:
输入:
s = "ab"
p = ".*"
输出: true
解释: " .* " 表示可匹配零个或多个（'*'）任意字符（'.'）。

示例 4:
输入:
s = "aab"
p = " c * a * b "
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。

示例 5:
输入:
s = "mississippi"
p = "mis * is * p *."
输出: false

### 解题思路
#### 1.递归解法
题目包含两个隐藏条件：
1. 一个就是*不会出现在字符串的开头
2. 另外一个是 * 前面不能是 * ，比如a * * b就不行
递归方式的求解，需要考虑两件事情，一是这个问题是否可以划分为子问题，二是每个子问题有几种可能的状态。
对于这个问题，字符串是可以划分为一个个的字符，字符串的比较问题可以转化为字符的比较问题。
对于字符串s，没有特殊字符，当前问题中字符全是字母，但是对于字符串p，需要考虑其中的字母以及特殊负号。这里列举出所有可能的情形，以当前的子问题是s[i,...n]和p[j,...m]:

s[i] == s[j]，子问题成立与否取决于子问题s[i+1,...n]和p[j+1,...m];
p[j] == '.'，子问题成立与否取决于子问题s[i+1,..n]和p[j+1,...m];
p[j+1] == '*', s[i] != p[j], 子问题成立与否取决于子问题s[i,...n]和p[j+2,...m];
p[j+1] == '*', s[i] == p[j], 子问题成立与否取决于子问题s[i+!,...n]和p[j,...m];

#### 2.动态规划
（一）状态
f[i][j]表示s1的前i个字符，和s2的前j个字符，能否匹配
（二）转移方程
1.如果s1的第i个字符和s2的第j个字符相同，或者s2的第j个字符为'.'
    f[i][j] = f[i-1][j-1]
2.如果s2的第j个字符为'*'
    1.若s2的第j个字符匹配0次第j-1个字符
        f[i][j] = f[i][j-2], 例如(ab, abc*)
    2.若s2的第j个字符匹配至少一次第j-1个字符
        f[i][j] = f[i-1][j] and s1[i] == s2[j-1] or s[j-1] == '.'
        这里注意不是f[i-1][j-1], 举个例子(abbb, ab*) f[4][3] = f[3][3]
（三）初始化
    f[0][i] = f[0][i-2] && s2[i] == *
    即s1的前0个字符和s2的前i个字符能否匹配
（四）结果
    f[m][n]
